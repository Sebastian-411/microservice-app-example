## üìù Local Deployment Report of Microservices üöÄ

### Introduction

This README details the process I followed to locally deploy a set of microservices in different languages and versions from a repository. The goal was to build a CRUD application for a to-do list. Throughout the process, I faced several technical challenges that I addressed using Docker and monitoring tools like Prometheus and Grafana. This document is designed as a resource to analyze my experience and establish a methodology to address similar issues in the future.

## Architecture
1. *üßë‚Äçüíª User API*:
   - *Technology*: Spring Boot (Java)
   - *Functionality*: Provides user profiles. Currently, it doesn't offer full CRUD functionality; it only allows fetching a single user or all users. This service is essential for managing and retrieving information about registered users.

2. *üîê Authentication API*:
   - *Technology*: Go
   - *Functionality*: Provides authentication functionality and generates JWT tokens that are used to authenticate requests to other APIs. This service ensures that only authenticated users can access certain resources.

3. *üìã TODOs API*:
   - *Technology*: NodeJS
   - *Functionality*: Provides CRUD operations (Create, Read, Update, Delete) on users' to-do list records. It also logs "create" and "delete" operations in a Redis queue for further processing. This service is the core of the to-do list application.

4. *üì® Log Message Processor*:
   - *Technology*: Python
   - *Functionality*: It is a queue processor that reads messages from a Redis queue and displays them in the standard output. Its purpose is to process and handle log events generated by the TODOs API.

5. *üñ•Ô∏è Frontend*:
   - *Technology*: Vue.js
   - *Functionality*: Provides the user interface (UI) to interact with the different microservices. It allows users to manage their tasks, view their profiles, and authenticate.

6. *üìä Monitoring with Prometheus and Grafana*:
   - *Prometheus*: Responsible for collecting and storing performance and operational metrics from the different microservices, providing visibility into the system's status.
   - *Grafana*: Provides a visual interface for monitoring the metrics collected by Prometheus, allowing developers and administrators to see the system's performance and health in real time.
   ## Architecture diagram 
   ![microservice-app-example](/arch-img/Microservices.png)

   ## Azure diagram
   [Click here](arch-img/azure-diagram.pdf)

   ## Deploy diagram (C4 - Context)
   ![microservice-app-example](/arch-img/c4-diagram.png)

   

### Initial Strategy

1. *üîó Fork and Clone the Repository*:
   - I forked the repository to my personal GitHub account to have my own working copy.
   - Then, I cloned the repository to my local machine to start working on it.

2. *üóÇÔ∏è Microservices Review*:
   - I examined each microservice folder, reviewing the README files to understand the specific requirements of each one and how to run them.

3. *‚öôÔ∏è Initial Local Execution*:
   - My first strategy was to try to run each microservice directly to identify potential compatibility issues between different language versions and dependencies.

### üõë Initial Problems and Strategy Change

- When attempting to run the first microservice, user-api, I encountered version compatibility issues. This type of problem is common when working on projects involving multiple languages and dependency versions.

- *Strategy Change: I decided to use **Docker** to encapsulate the microservices in containers, which would allow me to isolate their environments and avoid version conflicts.

### üê≥ Docker Implementation

1. *üìù Creating Dockerfiles*:
   - For each microservice, I created a *Dockerfile* based on the instructions in the README files. This allowed building Docker images that encapsulated all necessary dependencies.

2. *üîÑ Deploying Services*:
   - All services worked well in Docker containers, but I noticed they relied on an additional tool, *Zipkin*, to trace and map calls between microservices. Without Zipkin, the services could not communicate correctly with each other.

    ![microservice-app-example](/evidence-img/image1.png)

    #### frontend
    ![microservice-app-example](/evidence-img/image10.png)

    ##### Admin view
    ![microservice-app-example](/evidence-img/image12.png)

    ##### User view
    ![microservice-app-example](/evidence-img/image13.png)

3. *üõ†Ô∏è Solution for Zipkin*:
   - To solve this, I created a Docker image for *Zipkin* and configured the microservices to communicate with it, ensuring proper transaction tracing.

    ![microservice-app-example](/evidence-img/image4.png)

### üîÑ Automation with Docker Compose

1. *üóÇÔ∏è Docker Compose Configuration*:
   - To avoid manually running each container, I configured a docker-compose.yml file that defines all the services, their dependencies, and necessary environment variables.
   - This approach simplified deploying and managing microservices by automating the process of starting and stopping related services.

2. *üßπ Optimizing Docker Compose*:
   - I removed individual Dockerfiles for services like Redis and Zipkin, integrating them directly into the docker-compose.yml file. This reduced complexity and centralized deployment configuration.

    ![microservice-app-example](/evidence-img/image2.png)

#### Prometheus
![microservice-app-example](/evidence-img/image5.png)

#### Grafana

##### Login
![microservice-app-example](/evidence-img/image6.png)

##### Adding Prometheus
![microservice-app-example](/evidence-img/image7.png)

##### Metrics
![microservice-app-example](/evidence-img/image8.png)

##### Query execution
![microservice-app-example](/evidence-img/image9.png)

### üìä Monitoring with Prometheus and Grafana

1. *üõ†Ô∏è Implementation of Prometheus and Grafana*:
   - I added *Prometheus* and *Grafana* to the docker-compose.yml file to enable microservices monitoring.
   - I configured *Prometheus* to collect metrics and *Grafana* as a visual interface to monitor the performance and status of the services.

2. *üîç Configuring Microservices for Monitoring*:
   - For each microservice, it was necessary to expose metrics in a format that Prometheus could understand. This required different approaches depending on the microservice's implementation language:
     - For services in *Go* and *Python*, the configuration was relatively straightforward due to the good documentation and library support.
     - For services in *Java* with *Spring Boot*, I faced greater challenges due to incompatibilities with older versions of Prometheus libraries.

    ![microservice-app-example](/evidence-img/image3.png)


### ‚ö†Ô∏è Additional Issues and Solutions

- *üõ†Ô∏è `user-api` Microservice with Spring Boot*:
  - The *Java* and *Spring Boot* versions used were not compatible with standard Prometheus libraries, complicating integration.
  - I explored various GitHub repositories and tried different dependency configurations until I found a solution that worked. Initially, the metrics were returned in JSON format, which was incompatible with Prometheus.
  - Finally, I found a repository that used modified dependencies, allowing output compatible with Prometheus.

- *üåê Exposing Ports for `log-message`*:
  - Initially, I didn't correctly expose the necessary port to monitor the `log-message` service. This required me to update the Docker configuration and expose the appropriate port for monitoring.

### üõ†Ô∏è Running Locally
#### 1. **Building and Running Services Locally**

To build and run the services defined in the `docker-compose.yml` file, use:

```bash
docker-compose up --build
```

- **`--build`**: Forces the rebuild of images.

#### 2. **Stopping Services**

To stop running services, use:

```bash
docker-compose down
```

- This command stops and removes the containers, networks, and volumes defined in the `docker-compose.yml` file.

#### 3. **Removing Containers and Images**

To remove containers and images generated by Docker Compose, use:

```bash
docker-compose down --rmi all
```

- **`--rmi all`**: Removes all images associated with the services.

#### üåê Accessing the Application and Credentials

Once you have started the services using Docker Compose, you can access the application through your browser at the following URL:

- **URL**: `http://localhost:8000`

#### **Login Credentials**

To test the application's functionalities, use the following credentials to access different roles:

- **Administrator**:
  - **Username**: `admin`
  - **Password**: `admin`

- **User**:
  - **Username**: `john`
  - **Password**: `foo`

### üöÄ Pushing Images to a Docker Registry

To push a Docker image to a Docker Registry (like Docker Hub), follow these steps:

1. **Log in to the Docker Registry**:
   - Open your terminal and run the following command to log in to Docker Hub (or your Docker Registry):
     ```bash
     docker login
     ```
   - Enter your username and password when prompted.

2. **Tag the Image**:
   - Before pushing the image, you need to tag it with the appropriate format. Use the following command to tag the image:
     ```bash
     docker tag <image-name>:<tag> <dockerhub-username>/<repository-name>:<tag>
     ```
   - Example:
     ```bash
     docker tag user-api:latest myusername/user-api:latest
     ```

3. **Push the Image**:
   - Once the image is tagged, push the image to the Docker Registry using:
     ```bash
     docker push <dockerhub-username>/<repository-name>:<tag>
     ```
   - Example:
     ```bash
     docker push myusername/user-api:latest
     ```

This process will upload your image to the Docker Registry, making it available for download and use in other environments.

In this case, a script named `run.sh` located at the root of the repository was used to push all services.

### üìå Service Links

Here you can place links to repositories and relevant documentation for each service:

- **User API**: [Repository Link](https://hub.docker.com/repository/docker/sebastian411/users-api)
- **Authentication API**: [Repository Link](https://hub.docker.com/repository/docker/sebastian411/auth-api)
- **TODOs API**: [Repository Link](https://hub.docker.com/repository/docker/sebastian411/todos-api)
- **Log Message Processor**: [Repository Link](https://hub.docker.com/repository/docker/sebastian411/log-message-processor)
- **Frontend**: [Repository Link](https://hub.docker.com/repository/docker/sebastian411/frontend)
- **Prometheus**: [Documentation Link](https://prometheus.io/docs/introduction/overview/)
- **Grafana**: [Documentation Link](https://grafana.com/docs/grafana/latest/)